// исходный текст программы сохранен в кодировке UTF-8 без BOM

// unsigned-integer-overflow.cpp
// переполнение переменной целочисленного типа без знака размером в 1 байт

// В учебнике нет этой программы, я ее написал сам для иллюстрации изложенного
// в учебнике. В этой программе используются две вещи, которые к этому моменту
// в учебнике еще не рассмотрены: тип «unsigned char» и преобразование
// из одного типа в другой.

// в этой программе иллюстрируется, что случится, если в 8-битное целое без
// знака попробовать сохранить целое число 280

#include <iostream>

int main()
{
    // для переменной x я использую тип «unsigned char», так как этот тип
    // гарантирует, что переменная x будет занимать 1 байт (8 битов),
    // а возможный диапазон значений, которые можно будет хранить в этой
    // переменной — от 0 до 255 включительно

    // при инициализации переменной x я вынужден использовать копирующую
    // инициализацию вместо списочной, чтобы не было ошибки компиляции
    // (будут выданы только предупреждения)

    unsigned char x = 280;

    // при выводе значения переменной x в окно консоли я преобразую
    // значение этой переменной в число, чтобы увидеть число, а не символ;
    // это преобразование выполняется так: int(x)

    std::cout << int(x) << '\n'; // 24

    // поскольку число 280 не может влезть в переменную x, так как оно
    // не входит в диапазон значений 0..255, происходит следующая
    // операция: 280 / 256 == 1 (остаток: 24), в результате в переменную x
    // записывается число 24 (остаток от вышеописанного целочисленного деления)

    return 0;
}