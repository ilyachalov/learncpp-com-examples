// исходный текст программы сохранен в кодировке UTF-8 без BOM

// exponentiation-int-check-over.cpp
// операция возведения числа в степень (для значений целочисленных типов)
// с дополнительными проверками на переполнение

// в программе используется алгоритм «быстрого возведения в степень»
// (см. статью в википедии), когда вместо перемножения числа на себя
// множество раз (соответствующее показателю степени) число сначала
// возводится в квадрат, затем уже перемножается на себя квадрат исходного
// числа и так далее (поэтому в английском языке этот алгоритм называют
// «exponentiation by squaring»); этот алгоритм более эффективен, чем
// обычное перемножение исходного числа на себя множество раз

#include <cassert>  // для макроса assert
#include <cstdint>  // для типа std::int64_t
#include <iostream>
#include <limits>   // для шаблона класса std::numeric_limits

// более безопасная (и более медленная) версия функции, проверяет переполнение
// заметьте: степень exp должна быть неотрицательной
// возвращает std::numeric_limits<std::int64_t>::max() при переполнении
constexpr std::int64_t powInt_safe(std::int64_t base, int exp)
{
    assert(exp >= 0 && "powInt_safe: параметр exp имеет отрицательное значение");

    // обработка случая, когда в степень возводится число 0
    if (base == 0)
        return (exp == 0) ? 1 : 0;

    std::int64_t result{ 1 };

    // чтобы сделать проверки области значений легче, сделаем возводимое
    // в степень число положительным;
    // вернем результату знак после возведения в степень, если будет нужно
    bool negativeResult{ false };
    if (base < 0)
    {
        base = -base;
        negativeResult = (exp & 1);
    }

    while (exp > 0)
    {
        if (exp & 1) // если число exp является нечетным
        {
            // проверка: будет ли переполнен result при умножении на base
            if (result > std::numeric_limits<std::int64_t>::max() / base)
            {
                std::cerr << "powInt_safe(): result переполнен\n";
                return std::numeric_limits<std::int64_t>::max();
            }

            result *= base;
        }

        exp /= 2;

        // если мы закончили, выйти из цикла
        if (exp <= 0)
            break;

        // дальнейшее нужно, если мы должны продолжить цикл

        // проверка: будет ли base переполнена при умножении на себя
        if (base > std::numeric_limits<std::int64_t>::max() / base)
        {
            std::cerr << "powInt_safe(): base переполнена\n";
            return std::numeric_limits<std::int64_t>::max();
        }

        base *= base;
    }

    // это тот самый возврат результату знака, о котором говорилось выше
    if (negativeResult)
        return -result;

    return result;
}

int main()
{
    std::cout << powInt_safe(7, 12) << '\n'; // возведение числа 7 в степень 12
    std::cout << powInt_safe(7, 23) << '\n'; // переполнение

    return 0;
}