// исходный текст программы сохранен в кодировке UTF-8 без BOM

// knuth-func-approx-equal.cpp
// функция Дональда Кнута для определения того, что числа с плавающей запятой
// приблизительно равны

#include <iostream>
#include <algorithm> // для функции std::max
#include <cmath>     // для функции std::abs
#include <iomanip>   // для манипулятора std::setprecision

// буква «эпсилон» — одна из букв греческого алфавита, в математике этой
// буквой, в частности, обозначают очень небольшую положительную величину,
// в нашем случае relEpsilon и является такой величиной, приставка rel
// обозначает, что величина эта относительная, то есть подстраивается под
// сравниваемые числа a и b

// возвращает true (истина), если разница между a и b меньше или равна
// доле от большего из двух сравниваемых чисел a и b; эта доля определяется
// произведением relEpsilon с большим из двух сравниваемых чисел
// (я думаю, что подразумевается, что relEpsilon < 1)
bool approximatelyEqualRel(double a, double b, double relEpsilon)
{
    return (std::abs(a - b) <= (std::max(std::abs(a), std::abs(b)) * relEpsilon));
}

int main()
{
    // примеры применения функции approximatelyEqualRel

    double relEpsilon{ 0.001 }; // 0,1 % от большего из сравниваемых чисел
    std::cout << std::setprecision(10);

    // 1
    if (approximatelyEqualRel(1.0, 1.0001, relEpsilon))
        std::cout << 1.0 << " равно " << 1.0001 << '\n';
    else
        std::cout << 1.0 << " не равно " << 1.0001 << '\n';

    // 2
    if (approximatelyEqualRel(0.0000001, 0.00001, relEpsilon))
        std::cout << 0.0000001 << " равно " << 0.00001 << '\n';
    else
        std::cout << 0.0000001 << " не равно " << 0.00001 << '\n';

    // 3
    if (approximatelyEqualRel(10000.0, 10000.0001, relEpsilon))
        std::cout << 10000.0 << " равно " << 10000.0001 << '\n';
    else
        std::cout << 10000.0 << " не равно " << 10000.0001 << '\n';

    // результат работы этой программы у меня на компьютере:
    // 1 равно 1.0001          // разумно
    // 1e-07 не равно 1e-05    // разумно (разница на 2 порядка)
    // 10000 равно 10000.0001  // разумно

    // автор учебника считает работу функции approximatelyEqualRel
    // разумной во всех трех описанных выше случаях

    return 0;
}