// исходный текст программы сохранен в кодировке UTF-8 без BOM

// knuth-func-approx-issues.cpp
// функция Дональда Кнута для определения того, что числа с плавающей запятой
// приблизительно равны, тоже неидеальна

#include <algorithm> // для функции std::max
#include <cmath>     // для функции std::abs
#include <iostream>

// возвращает true (истина), если разница между a и b меньше или равна
// доле от большего из двух сравниваемых чисел a и b; эта доля определяется
// произведением relEpsilon с большим из двух сравниваемых чисел
// (я думаю, что подразумевается, что relEpsilon < 1)
bool approximatelyEqualRel(double a, double b, double relEpsilon)
{
    return (std::abs(a - b) <= (std::max(std::abs(a), std::abs(b)) * relEpsilon));
}

int main()
{
    // число a очень близко к 1.0, но не равно 1.0 из-за ошибок округления
    constexpr double a{ 0.1 + 0.1 + 0.1 + 0.1 + 0.1 +
                        0.1 + 0.1 + 0.1 + 0.1 + 0.1 };

    constexpr double relEps{ 1e-8 };

    // 1. Давайте сравним a (почти 1.0) с 1.0
    std::cout << approximatelyEqualRel(a, 1.0, relEps) << '\n';

    // 2. Давайте сравним a-1.0 (почти 0.0) с 0.0
    std::cout << approximatelyEqualRel(a - 1.0, 0.0, relEps) << '\n';

    // результат работы программы на моем компьютере:
    // 1
    // 0

    // как видим, во втором случае программа выдает неверный результат,
    // расчеты Дональда Кнута нарушаются, когда идет сравнение чисел около нуля

    return 0;
}